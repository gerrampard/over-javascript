# 03-对象的成员管理

## 一 对成员的常见操作

### 1.1 访问器与设置器

JS 的关键字 get、set 是对象总的访问器、设置器。我们通过点语法对对象进行属性的访问、设置，其内部其实是利用了访问器与设置器：

```js
const obj = {
  age: 10,
  get age() {
    console.log('访问器被调用')
    // 这里不能使用 this.age，this.age 同样也是调用了 get，会引起循环调用
    return 1 // 注意
  },
  set age(v) {
    console.log('设置器被调用')
  },
}

obj.age = 100 // 设置器被调用
console.log(obj.age) // 访问器被调用  输出1而不是10
```

由上看出，自定义的设置器、访问器，其优先级要比直接 `obj.age` 高，即如果访问器、设置的名称与对象中原有的属性名称一致，则以访问器、设置器为准，即他们的优先级更高。而且不能直接使用 `return age`，会引起循环引用。为了避免这些现象，一般推荐使用 下划线开头重新命名元素：

```js
const obj = {
  _age: 10,
  get age() {
    console.log('访问器被调用')
    return this._age
  },
  set age(v) {
    console.log('设置器被调用')
    this._age = v
  },
}

obj.age = 100 // 设置器被调用
console.log(obj.age) // 访问器被调用 100
```

通过上述方式，可以对原本的成员 age 进行简单保护！当然也可以如下方式书写：

```js
const obj = {
  data: {age :10}
  set age(v){
    age  = v;
  }
}
```

在 ES5 以前，开发者会使用两个非标准的访问创建访问器属性： `__defineGetter__()`和`__defineSetter__()`。

### 1.2 可计算属性

在以前，如果要让变量的值作为属性，必须：先声明对象，再使用中括号语法添加属性：

```js
const key = 'name'

let person = {}
person[key] = 'Matt'
```

现在，通过可计算属性，可以直接在字面量内完成赋值：

```js
const key = 'name'

let person = {
  [key]: 'Matt',
}
```

### 1.3 静态成员与 static 关键字

静态成员其实是通过构造函数、类能够直接使用的成员，无需使用实例调用：

```js
function Person() {}

// 静态属性
Person.sex = '男'

// 静态方法
Person.run = function () {
  console.log('running...')
}

console.log(Person.sex)
Person.run()
```

在 ES6 中，提供了关键字 static 用来描述静态成员：

```js
class Person {
  static sex = '男'
  static run() {
    console.log('running...')
  }
}

console.log(Person.sex)
Person.run()
```

静态成员一般是一些无需实例使用的属性，比如在 run()中无需使用 this，为了节省空间，可以将 run() 方法定义为静态方法。

## 二 成员特征

### 2.0 成员特征概念

对象的成员的特征可以用一些内特性来描述，比如可枚举型、是否可修改等，这些特性不能直接在 JS 中访问。

特征属性有两种：数据属性、访问器属性。

### 2.1 数据属性

数据属性有 4 个特性描述其行为：

- `[[Configurable]]`：默认值为 true，表示特性是否可以修改，包括是否可以 delete 删除，是否可以修改为访问器属性
- `[[Enumerable]]`：默认值为 true，表示是否可以枚举（即是否支持 for of 循环）
- `[[Writable]]`：默认值为 true，表示属性值是否可以被修改
- `[[Value]]`：默认值为 undefined，表示属性实际的值

使用 `Object.defineProperty()` 可以设置属性的特性，不过这种方式下 configurable、 enumerable 和 writable 的值如果不指定，则都默认为 false。

示例：

```js
let p = {}

Object.defineProperty(p, 'name', {
  writable: false,
  value: 'Lisi',
})

console.log(p.name) // Lisi
p.name = 'Zs'
console.log(p.name) // Lisi
```

一个属性如果被设置为不可配置后，再次设置其特性，会报错：

```js
let p = {}

Object.defineProperty(p, 'name', {
  configurable: false,
  value: 'Lisi',
})

// 抛出错误
Object.defineProperty(p, 'name', {
  configurable: true,
  value: 'Lisi',
})
```

### 2.2 访问器属性

访问器属性不包含数据值，包含两个非必须的函数：getter、setter，即访问器、设置器。访问器属性特征有四个 key：

- `[[Configurable]]`：默认值为 true，表示特性是否可以修改，包括是否可以 delete 删除，是否可以修改为数据属性
- `[[Enumerable]]`：默认值为 true，表示是否可以枚举（即是否支持 for of 循环）
- `[[Get]]`：默认值为 undefined，属性获取函数
- `[[Set]]`：默认值为 undefined，属性设置函数

访问器属性同样需要 `Object.defineProperty()` 定义：

```js
let book = {
  _year: 2017,
  edition: 1,
}

Object.defineProperty(book, 'year', {
  get() {
    return this._year
  },
  set(newValue) {
    if (newValue > 2017) {
      this._year = newValue
      this.edition += newValue - 2017
    }
  },
})

book.year = 2018
console.log(book.edition) // 2
```

## 三 属性特征的设置与读取

### 3.1 属性特征设置

Object.defineProperty() 只能设置某一个属性的特征，Object.defineProperties() 可以对多个属性进行设置：

```js
let book = {}

Object.defineProperties(book, {
  _year: {
    value: 2017,
  },
  edition: {
    value: 1,
  },
  year: {
    get() {
      return this._year
    },
    set(v) {
      if (v > 2017) {
        this.ye_yearar_ = v
        this.edition += v - 2017
      }
    },
  },
})
```

### 3.2 属性特征获取

使用 Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符：

```js
let desOfValue = Object.getOwnPropertyDescriptor(book, '_year')
console.log(desOfValue.value) // 2017
console.log(desOfValue.configurable) // false
console.log(typeof desOfValue.get) // "undefined"

let desOfValue2 = Object.getOwnPropertyDescriptor(book, 'year')
console.log(desOfValue2.value) // undefined
console.log(desOfValue2.enumerable) // false
console.log(typeof desOfValue2.get) // "function"
```

## 四 获取对象属性

某个属性可以通过对象访问到，in 操作符就会返回 true。而 hasOwnProperty() 只有在属性存在于实例上时才返回 true。从这里可以看出：只要 in 操作符返回 true 且 hasOwnProperty()返回 false，就说明该属性是一个原型属性。

```js
function Person() {}
Person.prototype.name = 'Lisi'

let p = new Person()
console.log('name' in p) // true
console.log(p.hasOwnProperty('name')) // false
```

同理，for-in 循环中，同样可以获取到**实例、原型**中的可枚举属性！

方法 `Object.keys()`可以获取**实例**中可枚举属性，返回数组：

```js
function Person(age) {
  this.age = age
}
Person.prototype.name = 'Lisi'

let p = new Person(30)

console.log(Object.keys(p)) // [ 'age' ]
```

方法 `Object.getOwnPropertyNames()` 用来获取实例所有属性，包括不可枚举属性：

```js
let keys = Object.getOwnPropertyNames(Person.prototype)
// constructor 不可枚举
console.log(keys) // "[constructor,name,age,job,sayName]"
```

方法`Object.getOwnPropertySymbols()` 与 方法 `Object.getOwnPropertyNames()` 类似，只是针对符号类型：

```js
let k1 = Symbol('k1'),
  k2 = Symbol('k2')

let o = {
  [k1]: 'k1',
  [k2]: 'k2',
}
console.log(Object.getOwnPropertySymbols(o))
// [Symbol(k1), Symbol(k2)]
```

注意：for-in 循环和 Object.keys()的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。Object.getOwnPropertyNames()、 Object.getOwnPropertySymbols()和 Object.assign()的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。

```js
let k1 = Symbol('k1'),
  k2 = Symbol('k2')
let o = {
  1: 1,
  first: 'first',
  [k1]: 'sym2',
  second: 'second',
  0: 0,
}
o[k2] = 'sym2'
o[3] = 3
o.third = 'third'
o[2] = 2
console.log(Object.getOwnPropertyNames(o))
// ["0", "1", "2", "3", "first", "second", "third"]
console.log(Object.getOwnPropertySymbols(o))
// [Symbol(k1), Symbol(k2)]
```
