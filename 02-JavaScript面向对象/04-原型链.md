# 04-原型链

## 一 原型链概念

### 1.0 理解原型

创建的函数都会拥有一个 prototype 属性，该属性指向了原型对象。原型对象也会获得一个名为 constructor 的属性，该属性指向与之关联的构造函数。比如 `Person.prototype.constructor` 指向 `Person`。

在定义一个构造函数时，原型对象默认只会获得 constructor 属性，其他默认方法都要继承自 Object。

new 出一个实例后，可以通过实例的 `__proto__` 属性来访问构造函数的原型对象。但是该属性并不是标准属性，只不过已经被各大浏览器接受并实现。

```js
function Person() {}

// 创建构造函数时就有两个属性：
// constructor：引用该构造函数
// __proto__： 指向 Object的原型对象
console.log(Person.prototype) // { constructor: f Person(), __proto__: Object}
console.log(Person.prototype.constructor === Person) // true

// 正常的原型链都会终止于 Object 的原型对象，Object的原型是null
console.log(Person.prototype.__proto__ === Object.prototype) // true
console.log(Person.prototype.__proto__.constructor === Object) // true
console.log(Person.prototype.__proto__.__proto__ === null) // true

// 构造函数、原型对象、实例对象是三个完全不同的对象
// 实例通过__proto__链接到原型对象，指向隐藏特性[[Prototype]]
// 构造函数通过 prototype 属性链接到原型对象
// 实例与构造函数没有直接联系，与原型对象有直接联系
console.log(person1.__proto__ === Person.prototype) // true
conosle.log(person1.__proto__.constructor === Person) // true

// 同一个构造函数创建的两个实例，共享同一个原型对象：
console.log(person1.__proto__ === person2.__proto__) // true

// 是否包含指定构造函数的原型
console.log(person1 instanceof Person) // true
console.log(person1 instanceof Object) // true
console.log(Person.prototype instanceof Object) // true
```

### 1.1 原型链介绍

在 JS 中，几乎所有对象都可以是原型对象，也可以是实例对象，还可以是构造函数。当一个对象身兼多职时，就可以看做一个节点，多个节点组成了一个链式结构，我们称之为原型链。

在原型链中，每个节点都可以通过一些属性来访问另外一个节点。

原型链的形成：

- 每个对象都有构造函数；
- 每个构造函数都有原型对象 prototype；
- 由于原型对象也是对象，所以原型对象也有构造函数，这个构造函数也有原型对象；
- 这样形成了一个链式结构，成为原型链；
- 最终的对象为 Object，Object.prototype 是原型链的终点。

### 1.2 属性搜索原则

```
1、先在自身实例查找
2、再去当前对象的原型中查找
3、再找原型的原型对象...依次向上查找
4、最后查找Objct.prototype
5、找不到报错
```

注意：

- 每个对象都连接到了一个原型对象，比鞥企鹅可以从中继承属性。
- 所有通过字面量创建的对象，都连接到了 Object.prototype 这个 JS 标准对象中。
- 新建对象时，可以选择某个对象作为新建对象的原型。但是这个原型对象只在属性检索中起到作用，在更新是不起作用！（即对新建对象作出改变时，不会更改原型对象）

## 二 **proto**

```js
function Person(name) {
  this.name = name
  this.run = function () {
    // 具备优先执行权
    console.log('构造函数内函数执行：' + this.name + ' is running')
  }
}

Person.prototype.run = function () {
  console.log('原型对象内函数执行：' + this.name + ' is running')
}

var p = new Person('lisi')
// p.run()
console.log(p.run()) // 先输出构造函数执行函数，再输出 undefined
```

原型链：对象内部都包含**proto**，那么会指向某个原型对象，这样依次往上递推，最后到达 Object 的原型对象，Object 的原型对象的**proto**指向了[Function]，Object 的原型对象 prototype 指向{}

```js
console.log(Object.__proto__) //[Function]
console.log(Object.prototype) //{}
```

## 三 原型链关系图

![](/images/JavaScript/JavaScript-02.png)

比如一个 Person 构造函数，一个实例对象 p:

```js
Person.prototype.constructor = Person
p.constructor = Person
p._proto_ = Person.prototype
p._proto_.constructor = Person
p._proto_.constructor = Person.prototype.constructor
```

注意：

```js
let obj = { name: 'lisi' }
obj.__proto__ = {
  show() {
    console.log(this.name)
  },
}

obj.__proto__ = 100

obj.show() // 仍然正常执行，因为本质上 __proto__ 是设置器在起作用，非对象无法设置
```

## 四 原型检测

### 4.1 判断对象是不是这个数据类型

- 第一种方法： 实例对象.构造器是否等于构造函数名
- 第二种方法： 对象 instanceof 构造函数名 （推荐）
  注意：需要共享的数据才会写在原型中，一般创建对象时肯定不会共享数据，而是共享方法，所以才会有创建对象时候上述推荐的创建方式。

### 4.2 检测是否在原型链上

```js
let a = { name: 'lisi' }
Object.prototype.age = 30
console.log('age' in a) // true in 会逐级检查原型链

let b = { sex: 1 }
Object.setPrototypeOf(a, b)
console.log(sex in a) // true
```

贴士：与 in 不同， `hasOwnProperty()` 只会检测对象自己。

## 五 如何安全扩展内置对象

我们不推荐扩展内置对象，但是可以使用下列方法更安全的扩展。

```javascript
function MyArray() {}
MyArray.prototype = new Array() //MyArray即成为了具备和Array一样的功能
```

## 六 总结

### 6.1 方法调用顺序

- 1 在对象自己内部查找
- 2 在原型中查找
- 3 以上属性没找到即 undefined，方法没找到就会报错 not a function

### 6.2 如何访问原型

- 构造函数访问原型：构造函数.prototype
- 实例对象访问原型：实例对象.**proto**
  由于部分浏览器不支持实例对象访问原型的方法，所以不推荐这样使用，仅在调试时使用。

### 6.3 对象属性

如果实例对象也创建了一个和原型一样的属性（属性名一样），那么不会去修改原型的值，而是给实例对象自己添加了属性。读取属性先找实例对象自己的，如果没有再去找原型。
注意：如果使用替换的方式替换原型，如果新原型没有 constructor 属性，会影响三角关系，为保证 `构造函数--原型---对象` 三者的合理，应在替换时候手动加入 constructor 属性。

### 6.4 注意事项

没有原型的对象是存在的：

```js
var obj = Object.create(null, {})
// 此时obj没有父亲！
```

## todo

```js
function Person() {}

let p1 = new Person()
let p2 = new Person()

// 使用 isPrototypeOf()方法确定两个对象之间的这种关系
console.log(Person.prototype.isPrototypeOf(p1)) // true
console.log(Person.prototype.isPrototypeOf(p2)) // true
```

Object 类型还有一个 setPrototypeOf()方法，可以向实例的私有特性`[[Prototype]]`写入一个新值。这样就可以重写一个对象的原型继承关系：

```js
let biped = {
  numLegs: 2,
}
let person = {
  name: 'Matt',
}
Object.setPrototypeOf(person, biped)
console.log(person.name) // Matt
console.log(person.numLegs) // 2
console.log(Object.getPrototypeOf(person) === biped) // true
```

`Object.setPrototypeOf()` 性能极其严重，可以通过 `Object.create()`创建一个新对象并指定原型：

```js
let biped = {
  numLegs: 2,
}
let person = Object.create(biped)
person.name = 'Matt'
console.log(person.name) // Matt
console.log(person.numLegs) // 2
console.log(Object.getPrototypeOf(person) === biped) // true
```

## todo 原型层级与搜索

访问实例对象属性的过程：

```txt
实例本身查找是否有属性-->原型上是否有属性
```

in 的使用：只要通过对象可以访问， in 操作符就返回 true，而 hasOwnProperty()只有属性存在于实例上
时才返回 true。因此，只要 in 操作符返回 true 且 hasOwnProperty()返回 false，就说明该属性
是一个原型属性。

```js
function Person() {}
Person.prototype.name = 'Nicholas'
Person.prototype.age = 29
Person.prototype.job = 'Software Engineer'
Person.prototype.sayName = function () {
  console.log(this.name)
}
let person1 = new Person()
let person2 = new Person()
console.log(person1.hasOwnProperty('name')) // false
console.log('name' in person1) // true
person1.name = 'Greg'
console.log(person1.name) // "Greg"，来自实例
console.log(person1.hasOwnProperty('name')) // true
console.log('name' in person1) // true
console.log(person2.name) // "Nicholas"，来自原型
console.log(person2.hasOwnProperty('name')) // false
console.log('name' in person2) // true
delete person1.name
console.log(person1.name) // "Nicholas"，来自原型
console.log(person1.hasOwnProperty('name')) // false
console.log('name' in person1) // true
```

在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举（ [[Enumerable]]特性被设置为 false）属性的实例属性也会在 for-in 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。

要获得对象上所有可枚举的实例属性，可以使用 Object.keys()方法。这个方法接收一个对象作
为参数，返回包含该对象所有可枚举属性名称的字符串数组。比如：

```js
function Person() {}
Person.prototype.name = 'Nicholas'
Person.prototype.age = 29
Person.prototype.job = 'Software Engineer'
Person.prototype.sayName = function () {
  console.log(this.name)
}
let keys = Object.keys(Person.prototype)
console.log(keys) // "name,age,job,sayName"
let p1 = new Person()
p1.name = 'Rob'
p1.age = 31
let p1keys = Object.keys(p1)
console.log(p1keys) // "[name,age]"
```

如果想列出所有实例属性，无论是否可以枚举，都可以使用 Object.getOwnPropertyNames()：

```js
let keys = Object.getOwnPropertyNames(Person.prototype)
// constructor 不可枚举
console.log(keys) // "[constructor,name,age,job,sayName]"
```

在 ECMAScript 6 新增符号类型之后，相应地出现了增加一个 Object.getOwnPropertyNames()的兄弟方法的需求，因为以符号为键的属性没有名称的概念。因此， Object.getOwnPropertySymbols()方法就出现了，这个方法与 Object.getOwnPropertyNames()类似，只是针对符号而已：

```js
let k1 = Symbol('k1'),
  k2 = Symbol('k2')

let o = {
  [k1]: 'k1',
  [k2]: 'k2',
}
console.log(Object.getOwnPropertySymbols(o))
// [Symbol(k1), Symbol(k2)]
```

for-in 循环、 Object.keys()、 Object.getOwnPropertyNames()、 Object.getOwnPropertySymbols()以及 Object.assign()在属性枚举顺序方面有很大区别。 for-in 循环和 Object.keys()的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。

Object.getOwnPropertyNames()、 Object.getOwnPropertySymbols()和 Object.assign()的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。

```js
let k1 = Symbol('k1'),
  k2 = Symbol('k2')
let o = {
  1: 1,
  first: 'first',
  [k1]: 'sym2',
  second: 'second',
  0: 0,
}
o[k2] = 'sym2'
o[3] = 3
o.third = 'third'
o[2] = 2
console.log(Object.getOwnPropertyNames(o))
// ["0", "1", "2", "3", "first", "second", "third"]
console.log(Object.getOwnPropertySymbols(o))
// [Symbol(k1), Symbol(k2)]
```

## 对象的迭代

ECMAScript 2017 新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法 Object.values()和 Object.entries()接收一个对象，返回它们内容的数组。 Object.values()返回对象值的数组， Object.entries()返回键/值对的数组。

```js
const o = {
  foo: 'bar',
  baz: 1,
  qux: {},
}
console.log(Object.values(o))

// ["bar", 1, {}]
console.log(Object.entries(o))
// [["foo", "bar"], ["baz", 1], ["qux", {}]]
```

非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制：

```js
const o = {
  qux: {},
}
console.log(Object.values(o)[0] === o.qux)
// true
console.log(Object.entries(o)[0][1] === o.qux)
// true
```

符号属性会被忽略：

```js
const sym = Symbol()
const o = {
  [sym]: 'foo',
}
console.log(Object.values(o))
// []
console.log(Object.entries(o))
// []
```
