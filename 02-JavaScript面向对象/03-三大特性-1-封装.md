# 03-三大特征-1-封装

## 一 成员的概念

### 1.1 成员基础操作

成员即对象的属性、方法等，可以通过 点语法 或者 [] 获取或者添加成员：

```js
let obj = {
  name: 'lisi',
  age: 30,
}

obj[0] = function () {
  console.log('添加成功')
}

// 在以前，如果要让变量的值作为属性，必须：先声明对象，再使用中括号语法添加属性：
const key1 = 'name'
obj[key1] = 'Matt'

// 现在，通过可计算属性，可以直接在字面量内完成赋值：
const key2 = 'age'
let person = {
  [key2]: 30,
}

// 删除成员
delete obj.age // delete 不能删除原型上的属性，所以也不能删除继承属性！
```

贴士：从通过[]可以访问成员可以看出，JS 的对象其实就是一个字典（或者说哈希表、散列表），其构造类似于 ES6 中的 Map。 可以通过 for in 来遍历对象中的元素。

### 1.2 静态成员与 static 关键字

静态成员其实是通过构造函数、类能够直接使用的成员，无需使用实例调用：

```js
function Person() {}

// 静态属性
Person.sex = '男'

// 静态方法
Person.run = function () {
  console.log('running...')
}

console.log(Person.sex)
Person.run()
```

在 ES6 中，提供了关键字 static 用来描述静态成员：

```js
class Person {
  static sex = '男'
  static run() {
    console.log('running...')
  }
}

console.log(Person.sex)
Person.run()
```

静态成员一般是一些无需实例使用的属性，比如在 run()中无需使用 this，为了节省空间，可以将 run() 方法定义为静态方法。

## 二 封装概念

> 封装：将对象的某些成员隐藏，不允许外部程序直接访问。

经过封装的成员只能通过规定好的方式访问，可以隐藏一些细节，方便修改、实现。

在 JavaScript 中，通过设置器、访问器可以对成员进行初步封装，也可以通过 `Object.defineProperty()` 方法对成员的特征进行限制。

## 三 访问器与设置器

JS 的关键字 get、set 是对象总的访问器、设置器。我们通过点语法对对象进行属性的访问、设置，其内部其实是利用了访问器与设置器：

```js
const obj = {
  age: 10,
  get age() {
    console.log('访问器被调用')
    // 这里不能使用 this.age，this.age 同样也是调用了 get，会引起循环调用
    return 1 // 注意
  },
  set age(v) {
    console.log('设置器被调用')
  },
}

obj.age = 100 // 设置器被调用
console.log(obj.age) // 访问器被调用  输出1而不是10
```

由上看出，自定义的设置器、访问器，其优先级要比直接 `obj.age` 高，即如果访问器、设置的名称与对象中原有的属性名称一致，则以访问器、设置器为准，即他们的优先级更高。而且不能直接使用 `return age`，会引起循环引用。为了避免这些现象，一般推荐使用 下划线开头重新命名元素：

```js
const obj = {
  _age: 10,
  get age() {
    console.log('访问器被调用')
    return this._age
  },
  set age(v) {
    console.log('设置器被调用')
    this._age = v
  },
}

obj.age = 100 // 设置器被调用
console.log(obj.age) // 访问器被调用 100
```

通过上述方式，可以对原本的成员 age 进行简单保护！当然也可以如下方式书写：

```js
const obj = {
  data: {age :10}
  set age(v){
    age  = v;
  }
}
```

在 ES5 以前，开发者会使用两个非标准的访问创建访问器属性： `__defineGetter__()`和`__defineSetter__()`。

## 四 成员特征

### 4.0 成员特征概念

对象的成员的特征可以用一些内特性来描述，比如可枚举型、是否可修改等，这些特性不能直接在 JS 中访问。

特征属性有两种：数据属性、访问器属性。

### 4.1 数据属性

数据属性有 4 个特性描述其行为：

- `[[Configurable]]`：默认值为 true，表示特性是否可以修改，包括是否可以 delete 删除，是否可以修改为访问器属性
- `[[Enumerable]]`：默认值为 true，表示是否可以枚举（即是否支持 for of 循环）
- `[[Writable]]`：默认值为 true，表示属性值是否可以被修改
- `[[Value]]`：默认值为 undefined，表示属性实际的值

使用 `Object.defineProperty()` 可以设置属性的特性，不过这种方式下 configurable、 enumerable 和 writable 的值如果不指定，则都默认为 false。

示例：

```js
let p = {}

Object.defineProperty(p, 'name', {
  writable: false,
  value: 'Lisi',
})

console.log(p.name) // Lisi
p.name = 'Zs'
console.log(p.name) // Lisi
```

一个属性如果被设置为不可配置后，再次设置其特性，会报错：

```js
let p = {}

Object.defineProperty(p, 'name', {
  configurable: false,
  value: 'Lisi',
})

// 抛出错误
Object.defineProperty(p, 'name', {
  configurable: true,
  value: 'Lisi',
})
```

### 4.2 访问器属性

访问器属性不包含数据值，包含两个非必须的函数：getter、setter，即访问器、设置器。访问器属性特征有四个 key：

- `[[Configurable]]`：默认值为 true，表示特性是否可以修改，包括是否可以 delete 删除，是否可以修改为数据属性
- `[[Enumerable]]`：默认值为 true，表示是否可以枚举（即是否支持 for of 循环）
- `[[Get]]`：默认值为 undefined，属性获取函数
- `[[Set]]`：默认值为 undefined，属性设置函数

访问器属性同样需要 `Object.defineProperty()` 定义：

```js
let book = {
  _year: 2017,
  edition: 1,
}

Object.defineProperty(book, 'year', {
  get() {
    return this._year
  },
  set(newValue) {
    if (newValue > 2017) {
      this._year = newValue
      this.edition += newValue - 2017
    }
  },
})

book.year = 2018
console.log(book.edition) // 2
```

## 五 属性特征的设置与读取

### 5.1 属性特征设置

Object.defineProperty() 只能设置某一个属性的特征，Object.defineProperties() 可以对多个属性进行设置：

```js
let book = {}

Object.defineProperties(book, {
  _year: {
    value: 2017,
  },
  edition: {
    value: 1,
  },
  year: {
    get() {
      return this._year
    },
    set(v) {
      if (v > 2017) {
        this.ye_yearar_ = v
        this.edition += v - 2017
      }
    },
  },
})
```

### 5.2 属性特征获取

使用 Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符：

```js
let desOfValue = Object.getOwnPropertyDescriptor(book, '_year')
console.log(desOfValue.value) // 2017
console.log(desOfValue.configurable) // false
console.log(typeof desOfValue.get) // "undefined"

let desOfValue2 = Object.getOwnPropertyDescriptor(book, 'year')
console.log(desOfValue2.value) // undefined
console.log(desOfValue2.enumerable) // false
console.log(typeof desOfValue2.get) // "function"
```
