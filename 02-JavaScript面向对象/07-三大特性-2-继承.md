# 07-三大特性-2-继承

## 一 继承概述

继承是 OO 语言的重要概念，描述了对象与对象之间父子关系。分为两种继承方式：

- 接口继承：只继承方法签名，继承者自己来实现具体的方法。
- 实现继承：直接继承父类的方法

JS 的函数没有签名一说，无法实现面向接口编程，JS 的实现继承在使用对象的属性、方法时，会沿着原型链依次向上查找，所以原型链其实是实现继承的主要方法。

简单来说：继承其实就是让一个引用类型，也具备了另一个引用类型的属性、方法。

## 二 JS 中继承的实现

### 2.2 基于原型继承的实现

```js
// 父类
function Father() {
  this.surname = 'li' // 姓氏
  this.age = 30
  this.friends = ['a', 'b', 'c']
}

Father.prototype.run = function () {
  console.log('Father run...') // 跑步，可以继承
}

// 子类
function Son() {
  this.age = 5
}

// 子类继承父类：构建一个父类的实例赋值给子类原型，则子类原型就拥有了所有父类成员
Son.prototype = new Father()

// 测试
var s1 = new Son()
console.log(s1 instanceof Object) // true
console.log(s1 instanceof Father) // true
console.log(s1 instanceof Son) // true
console.log(s1.surname) // "li"
console.log(s1.age) // 5 是自己的属性
s1.run() // 直接调用父类方法：Father run...
```

在上述案例中，虽然完整的实现了继承的各个要素：继承属性、继承方法，但是这里有一个极大的隐患：

```js
var s1 = new Son()
s1.friends.push('d')
console.log(s1.friends) // [ 'a', 'b', 'c', 'd' ]

var s2 = new Son()
console.log(s2)
console.log(s2.friends) // [ 'a', 'b', 'c', 'd' ]
```

在上述示例中，子类的原型是父类的具体的一个实例，我们发现子类 s1 修改 **引用类属性** 时，另外一个子类 s2 也受到了影响！！！！Son 类的 2 个实例 s1，s2 在调用继承过来的属性时，使用的都是其原型，而其原型恰好是父类的实例。

## 三 继承的完整实现：组合继承

在上一章中，原型继承与构造函数继承都有其缺陷，在实际中笔者认为不能直接使用。

组合继承：将上一章的构造函数继承、原型继承进行组合即可。

```js
// 父类
function Father() {
  this.surname = 'li' // 姓氏
  this.age = 30
  this.friends = ['a', 'b', 'c']
}

Father.prototype.run = function () {
  console.log('Father run...') // 跑步，可以继承
}

// 子类
function Son() {
  Father.call(this) // 调用父类属性时，指针修改为Son
  this.age = 5
}

// 子类继承父类：构建一个父类的实例赋值给子类原型，则子类原型就拥有了所有父类成员
Son.prototype = new Father()
```

组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。而且， instanceof 和 isPrototypeOf()也能够用于识别基于组合继承创建的对象。

组合继承的缺陷：父类构造函数被二次调用了！详间 07-2 拷贝继承。

## 一 原型式继承（拷贝继承）

### 1.1 原型式继承的实现

2006 年，道格拉斯· 克罗克福德在他的文章中红描述了一种继承方法：原型式继承，该方法是没有使用严格意义上的构造函数，只是借助原型，基于已有的对象创建新对象，同时还不必因此创建自定义类型：

```js
function inherit(obj) {
  function F() {} // 首先创建一个临时构造函数
  F.prototype = obj
  return new F() // 返回该临时构造函数的实例
}
```

现在来测试这个继承函数：

```js
// 父类：由于方法要求必须是实例，这里可以使用字面量（本身就是实例）
var p = {
  surename: 'li',
  friends: ['a', 'b', 'c'],
  run: function () {
    console.log('Father run...')
  },
}

// 子类
var p1 = inherit(p)
console.log(p1.friends) //  [ 'a', 'b', 'c' ]
p1.run() //  Father run...

// 再建一个子类
p1.friends.push('d') // 先修改p1的属性
var p2 = inherit(p)
console.log(p2.friends) // 已被修改：[ 'a', 'b', 'c', 'd' ]
```

其实这是一种浅拷贝，ES5 提供了 `Object.create()`函数规范了上述方式：

```js
// 父类
var p = {
  surename: 'li',
  friends: ['a', 'b', 'c'],
  run: function () {
    console.log('Father run...')
  },
}

// 子类
var p1 = Object.create(p)
console.log(p1.friends) //  [ 'a', 'b', 'c' ]
p1.run() //  Father run...

// 再建一个子类
p1.friends.push('d') // 先修改p1的属性
var p2 = Object.create(p)
console.log(p2.friends) // 已被修改：[ 'a', 'b', 'c', 'd' ]
```

create()方法还有第二个参数可以用来自定义子类对象的属性：

```js
var p1 = Object.create(p, {
  name: {
    value: 'lisi',
  },
})
console.log(p1.name) //  lisi
```

这种基于 Object.create 的方式，不必要使用麻烦的构造函数，但是要注意的是：父类的引用类型是会被共享的！

### 1.2 寄生式继承（工厂函数）

该方式也是克罗克福德提出的，其实是一种工厂函数，只是在复制父类后的一种增强/自定义：

```js
function inherit(obj) {
  var clone = Object.create(obj)
  obj.sayHi = function () {
    console.log('hi...')
  }
  return clone
}
```

### 1.3 错误提示

上述方式需要防止参数的误传：

```js
// 传入对象obj
function inherit(father) {
  if (father == null) {
    throw TypeError()
  }

  if (Object.create) {
    return Object.create(father)
  }

  var t = typeof father
  if (t !== 'object') {
    throw TypeError()
  }

  function f() {}
  f.prototype = father
  return new f()
}
```

## 二 拷贝继承最终版：寄生组合式继承

在 06-2 继承章节中，继承的最终版是组合式继承，但是该继承其实也有一个缺陷：父类构造函数的二次调用

```js
// 父类
function Father() {
  this.surname = 'li'
  this.age = 30
  this.friends = ['a', 'b', 'c']
}

Father.prototype.run = function () {
  console.log('Father run...')
}

// 子类
function Son() {
  Father.call(this) // 第二次调用Father
  this.age = 5
}

// 第一次调用： Father()
Son.prototype = new Father()
```

所谓寄生组合式继承，即：

- 通过构造函数来继承属性
- 通过原型链的混成形式来继承方法

其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。

```js
// 父类
function Father() {
  this.surname = 'li'
  this.age = 30
  this.friends = ['a', 'b', 'c']
}

Father.prototype.run = function () {
  console.log('Father run...')
}

// 子类
function Son() {
  Father.call(this) // 仅仅这里调用一次
  this.age = 5
}

// 子类实现：这2步其实可以封装为一个ES6 extend 函数，即 create一个新对象，然后拷贝Father的原型属性

// 这里也不能简单的直接写为； Son.prototype=Father.prototype，这样写修改子类prototype会影响父类
Son.prototype = Object.create(Father.prototype)
// 由于是新对象，其构造器为Object
Son.prototype.constructor = Son

// 子类自定义
Son.prototype.sayAge = function () {
  console.log('Age is ', this.age)
}

// 使用
var s = new Son()
console.log(s.surname) // li
s.sayAge() // Age is  5
```

## 三 ES6 中的继承

ES6 的继承通过 extends 关键字实现：

```js
class Person {
  constructor(name, age) {
    // 构造函数部分
    this.name = name
    this.age = age
  }
  run() {
    console.log(this.name + ' is running...')
  }
}

class Student extends Person {
  constructor(name, age, room) {
    super(name, age) // 必须调用父类的构造一次
    this.room = room
  }
}
```
