# 05-对象的检测

## 一 类型检测

### 1.0 JS 类型检测机制

在使用构造函数创建对象时，构造函数的 prototype 属性被用作新对象的原型，这意味着通过同一个构造函数创建的所有对象都继承自一个相同的对象，他们都是同一个类的类型！

原型对象是类的唯一标识，两个不同的构造函数，其原型对象如果一样，那么这 2 个构造函数创建出来的实例其实是一个类型。

在 ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力：

```js
// 这些是===符合预期的情况
console.log(true === 1) // false
console.log({} === {}) // false
console.log('2' === 2) // false
// 这些情况在不同 JavaScript 引擎中表现不同，但仍被认为相等
console.log(+0 === -0) // true
console.log(+0 === 0) // true
console.log(-0 === 0) // true
// 要确定 NaN 的相等性，必须使用极为讨厌的 isNaN()
console.log(NaN === NaN) // false
console.log(isNaN(NaN)) // true
```

为改善这类情况， ECMAScript 6 规范新增了 Object.is()，这个方法与===很像，但同时也考虑到了上述边界情形。这个方法必须接收两个参数：

```js
console.log(Object.is(true, 1)) // false
console.log(Object.is({}, {})) // false
console.log(Object.is('2', 2)) // false
// 正确的 0、 -0、 +0 相等/不等判定
console.log(Object.is(+0, -0)) // false
console.log(Object.is(+0, 0)) // true
console.log(Object.is(-0, 0)) // false
// 正确的 NaN 相等判定
console.log(Object.is(NaN, NaN)) // true
```

要检查超过两个值，递归地利用相等性传递即可：

```js
function recursivelyCheckEqual(x, ...rest) {
  return (
    Object.is(x, rest[0]) && (rest.length < 2 || recursivelyCheckEqual(...rest))
  )
}
```

### 1.1 instanceof 检测方式

```js
function A() {}

let a = new A()

// instanceof 会顺着原型链一直查找
console.log(a instanceof A) // true
console.log(a instanceof Object) // true
```

### 1.2 isPrototypeOf() 检测类型

```js
function A() {}

let a = new A()
let b = new A()

console.log(a.__proto__.isPrototypeOf(b)) // true
console.log(A.prototype.isPrototypeOf(b)) // true
console.log(Object.prototype.isPrototypeOf(b)) // true

console.log(a.isPrototypeOf(b)) // false
console.log(Object.isPrototypeOf(b)) // false
```

## 三 属性检测

### 3.1 in 属性检测

for in 是可以检测原型链上的属性的：

```js
let a = { name: 'lisi' }
Object.prototype.age = 30

console.log('age' in a) // true
```

Object 提供了方法可以直接设置实例的原型：

```js
let a = { age: 30 }
let b = { name: 'zs' }
Object.setPrototypeOf(a, b)
console.log('age' in a) // true
```

### 3.2 hasOwnProperty() 只检查当前对象

```js
let a = { name: 'lisi' }
Object.prototype.age = 30

console.log(a.hasOwnProperty('name')) // true
console.log(a.hasOwnProperty('age')) // false
```

## 四 constructor 属性

原型对象上默认会拥有一个 constructor 属性，该属性的值即为构造函数名：

```js
function Person(name) {
  this.name = name
}

console.log(Person.prototype.constructor) // [Function: Person]
```

如果一个类存在多个实例方法，则每次都要全新书写 `类名.prototype.方法名 = function(){}`，其实可以简写为如下方式：

```js
Person.prototype = {
    constructor: Person,       //需要手动书写构造器指向，如果没有该句，则创建的对象会少了constructor属性。
    eat: function(){},
    dance: function(){},
    ...
}
```

所以获取一个对象的类型（也可以说是类名），现在有两种方法：

- instanceof：`p instanceof Person`
- constructor：`p.__proto__.constructor`，结果为： `[Function: Person]`

## 四 原型检测

### 4.1 判断对象是不是这个数据类型

- 第一种方法： 实例对象.构造器是否等于构造函数名
- 第二种方法： 对象 instanceof 构造函数名 （推荐）
  注意：需要共享的数据才会写在原型中，一般创建对象时肯定不会共享数据，而是共享方法，所以才会有创建对象时候上述推荐的创建方式。

### 4.2 检测是否在原型链上

```js
let a = { name: 'lisi' }
Object.prototype.age = 30
console.log('age' in a) // true in 会逐级检查原型链

let b = { sex: 1 }
Object.setPrototypeOf(a, b)
console.log(sex in a) // true
```

贴士：与 in 不同， `hasOwnProperty()` 只会检测对象自己。
