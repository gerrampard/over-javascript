# 06-H5 的变化总结

## 序 HTML5 概念

HTML 只是一个纯标记语言，JS 绑定事件都交给了 DOM 规范。但是 H5 规范包含了大量的 JS 的 API，其覆盖范围极广。

最常见的 H5 功能：

- 更规范简介的 HTML 文档
- 更多的标签语义化
- 针对 BOM 的变化：
  - history 中的状态记录管理
  - localStorage 等存储机制
  - navigator.geolocation 地理位置等
- 针对 DOM 的变化：
  - className、classList 对元素的 CSS 类名进行操作
  - focus() 方法获取焦点
  - 标准化了 document.compatMode，可以获取渲染模式
  - 标准化了自定义属性操作
  - 标准化了 innerHTML 属性
  - 标准化了滚动相关：scrollIntoView()
- 一些高级功能：
  - 跨文档通信
  - 离线应用

## 一 对 HTML 的增强

更规范的 HTML 文档规范，更多的语义化标签。

## 二 对 BOM 的增强

history 对象可以进行状态记录管理。

新增了 localStorage、sessionStorage 等存储机制。

navigator.geolocation 支持地理位置操作。

## 三 DOM 变化

### 3.1 通过 class 类名操作元素

document.getElementsByClassName() 是 H5 新增的方法。

className 属性 现在也可以直接通过元素获取：

```js
// 要删除"user"类
let targetClass = 'user'
// 把类名拆成数组
let classNames = div.className.split(/\s+/)
// 找到要删除类名的索引
let idx = classNames.indexOf(targetClass)
// 如果有则删除
if (idx > -1) {
  classNames.splice(i, 1)
}
// 重新设置类名
div.className = classNames.join(' ')
```

H5 为元素新增了 classList 属性，支持对类名进行增删改查：

```js
// 删除"disabled"类
div.classList.remove('disabled')
// 添加"current"类
div.classList.add('current')
// 切换"user"类
div.classList.toggle("user");
// 检测类名
if (div.classList.contains("bd") && !div.classList.contains("disabled")){
// 执行操作
)
// 迭代类名
for (let class of div.classList){
doStuff(class);
}
```

### 3.2 自定义属性

H5 规定使用 data- 来描述元素的自定义属性：

```html
<div id="myDiv" data-appId="12345" data-myname="Nicholas"></div>
<script>
  let div = document.getElementById('myDiv')
  // 取得自定义数据属性的值
  let appId = div.dataset.appId
  let myName = div.dataset.myname
  // 设置自定义数据属性的值
  div.dataset.appId = 23456
  div.dataset.myname = 'Michael'
</script>
```

### 3.3 插入标记 innerHTML 与 outerHTML

IE8 中使用 `元素.innerHTML=''` 时，如果内部包含 script 标签，且指定了 defer 属性，若 script 标签之前是非受控元素，脚本是可以执行的。

而当前的主流浏览器中 innerHTML 插入的脚本是不会执行的。

### 3.4 焦点管理

```js
button.focus()
alert(document.hasFocus()) //true 确定文档是否获得了焦点
alert(document.activeElement === button) //true
```

默认情况下，文档刚刚加载完成时， document.activeElement 中保存的是 document.body 元素的引用。文档加载期间， document.activeElement 的值为 null。

### 3.6 HTMLDocument 变化

H5 规范了 readyState 属性，其值有：

- loading，正在加载文档；
- complete，已经加载完文档

H5 规范了 compatMode 属性，用于告知开发人员浏览器采用了哪种渲染模式：

```js
if (document.compatMode == 'CSS1Compat') {
  // 标准模式
  alert('Standards mode')
} else {
  alert('Quirks mode') // 混杂模式
}
```

document.body 很好用，H5 又引入了 document.head 属性。

H5 引入了`document.charset = "UTF-8";`用于设置字符集。如果文档没有使用默认的字符集，那 charset 和 defaultCharset 属性的值可能会不一样，例如：

```js
if (document.charset != document.defaultCharset) {
  alert('Custom character set being used.')
}
```

### 3.7 HTML5 新增属性

```txt
hidden：        hidden属性可以代替CSS样式中的display属性
spellcheck：    表单元素的该属性支持true、false属性值，以判断是否需要浏览器对文本进行校验，如：对拼错的单词进行提示。
disabled：      新属性disabled直接就可以让input无法选择，而老版的html中要使用:disabled="disabled"
```

## 四 其他功能

### 4.1 离线应用

离线应用可以帮助用户在没有网络时使用 web 程序，H5 的离线功能包含：离线资源缓存、在线状态监测、本地数据存储等。  
离线 web 应用比普通的 web 应用多了一个描述文件，该文件用来列出需要缓存和永不缓存的资源，描述文件的扩展名为：.manifest 或者 .appcache(推荐使用)。  
首先需要在项目目录下创建 offline.appcache 文件：

```txt
CACHE MANIFEST      # 说明这是离线应用描述文件
CACHE:              # 会被缓存的资源列表
index.html
index.js
NETWORK:            # 总是从web获取的资源列表
test.js
```

html 文件需要添加如下配置：

```html
<html lmanifest="./offline.appcache"></html>
```

### 4.2 跨文档通信

在过去，跨文档通信（跨源、跨窗口，cross-document messaging）往往是与服务端进行数据交互来实现的，并且需要借助轮询或者 Connect 技术来监听消息。

H5 提供了 PostMessages()方法 实现安全的跨源通信：

```js
// 参数一：消息体
// 参数二：消息来自哪个域
// 参数三：可选。是一串和message同时传递的Transferable对象，这些对象的所有权将被转译给消息的接收方，而发送乙方将不再保有所有权

let iframeWindow = document.getElementById('myframe').contentWindow
iframeWindow.postMessage('A secret', 'http://www.demo.com')
```

iframe 应用实例：

```html
<button id="btn">点击发送消息给iframe</button>
<iframe src="http:127.0.0.1/iframe.html"></iframe>
<script>
  let btn = document.querySelector('#btn')
  let data = ['周一', '周二', '周五']
  btn.onclick = function () {
    alert('执行发送数据给iframe？')
    window.parent.postMessage(data, 'http:127.0.0.1/iframe.html')
  }
</script>
```

iframe 接受数据：

```javascript
    <script>
        window.addEventListener("data", e =>{
            console.log("origin=", e.origin);
            console.log("data=", e.data);
        });
    </script>
```

### 4.3 H5 原生拖放

在 H5 规范中，拖动元素，将依次触发：`dragstart`，`drag`，`dragend`三个事件。

当某个元素被拖动到一个有效的放置目标上时，将依次触发：`dragenter`，`dragover`，`dragleave/drop`三个事件。如果拖拽元素离开了目标元素位置，则触发 dragleav 事件，如果放置到了目标元素位置，则触发 drop 事件。

如果拖动元素经过不允许放置的元素，无论用户如何操作，都不会发生 drop 事件。不过，任何元素都可以被设置为放置目标元素。

设置元素可以放置方式是重写 dragenter、dragover 事件的默认行为：

```js
let droptarget = document.getElementById('droptarget')
EventUtil.addHandler(droptarget, 'dragover', function (event) {
  EventUtil.preventDefault(event)
})

EventUtil.addHandler(droptarget, 'dragenter', function (event) {
  EventUtil.preventDefault(event)
})
```

在 Firefox 中，若拖拽图像，则页面会转向图像文件，若拖拽文本，则会导致无效 URL 错误，所以这里需要取消 Firefox 的 drop 事件的默认行为，阻止其打开 URL：

```js
EventUtil.addHandler(droptarget, 'drop', function (event) {
  EventUtil.preventDefault(event)
})
```

dataTransfer 对象是拖拽事件对象的属性，用于存储数据：

```js
//设置和接收文本数据
event.dataTransfer.setData('text', 'some text')
let text = event.dataTransfer.getData('text')
//设置和接收 URL
event.dataTransfer.setData('URL', 'http://www.wrox.com/')
let url = event.dataTransfer.getData('URL')
```

默认情况下，图像、链接和文本是可以拖动的，也就是说，不用额外编写代码，用户就可以拖动它们。文本只有在被选中的情况下才能拖动，而图像和链接在任何时候都可以拖动。

HTML5 为所有 HTML 元素规定了一个 draggable 属性，表示元素是否可以拖动。图像和链接的 draggable 属性自动被设置成了 true，而其他元素这个属性的默认值都是 false。

### 4.4 文件对象

H5 中通过 `<input>` 可以得到一个 Files 对象（伪数组）：

```js
let obj = document.querySelector('input') // 必须设置input为 mutipart
obj.onchange = function () {
  // 所有的文件
  console.log(this.files) // 是维数组的原因：input一次可以选择多个文件

  // 读取文件内容！
  let reader = new FileReader()
  reader.readAsText(this.files[0])

  // 文件读取完毕
  reader.onload = function () {
    console.log(this.result)
  }
}
```
